#+Title:关于CocosBuilder控件的实现
本文档描述了使用CocosBuilder制作界面中，实现控件的一般方法和流程。

** 实现控件的流程
*** 实现控件
+ 实现游戏中使用的控件。
#+BEGIN_EXAMPLE
使用cocos2d-x提供的元素实现游戏中使用的控件。
#+END_EXAMPLE

*** 实现控件的编辑
+ 列出控件的所有属性。
#+BEGIN_EXAMPLE
这个步骤是用来理清楚控件有哪些属性。

例如: CCControlSlider的属性有
backgroundSpriteFrame
progressSpriteFrame
thumbSpriteFrame
maximumValue
minimumValue
value
#+END_EXAMPLE

+ 制作控件的Plugin
#+BEGIN_EXAMPLE
这个步骤的作用是告诉CocosBuilder，需要列出控件的哪些属性来编辑。以及需要将控件的哪些属性保存到文件中。

首先复制CCRotateSpritePlugin Project，修改项目名称为CCControlSlider
其次结合上面列出的属性，修改CCBPProperties.plist文件。

CCBPProperties.plist中数据编辑需要注意的几个问题:
dontSetInEditor 该字段是用来指定属性是否是用来编辑的，例如Separator类型的属性中，必须指定dontSetInEditor为YES
IntegerLabeled  类型通常是用来对应枚举类型的属性的。
#+END_EXAMPLE

+ 实现控件的显示和编辑
#+BEGIN_EXAMPLE
这个步骤的作用是扩展CocosBuilder,这样，就可以在CocosBuilder中显示和编辑上面制作出来的控件了。
(1)对于cocos2d中已经有的控件，我们只要对已有控件进行扩展，来满足编辑需求就可以了。例如CCProgressTimer(Help)和CCControlSlider(Help)。
(2)对于我们自己定义的控件，我们需要使用cocos2d提供的元素，配合OpenGL来模拟我们自定义的控件，添加需要编辑的属性。例如:CCEditBox
#+END_EXAMPLE

** CocosBuilder 维护问题记录
*** 添加新分支
#+BEGIN_EXAMPLE
问题说明：
需要以real_origin的最新源码为基础，添加新分支，并把自己以前修改的东西添加进去。
操作方法：
第一步：CocosBuilder源代码的修改
1、先将CustomWidget作为submodule添加到最新源码中。
2、用原来代码中根目录下的PlugIn Nodes目录替换新建的基础代码对应的目录。
3、根据之前的commit日志，将自己修改的代码merge到新建的基础代码中。
第二部：cocos2d-x源代码的修改

#+END_EXAMPLE
*** 在C++中读取xml配置然后设置控件属性的时候，如何保证按照特定的顺序设置控件属性呢?
+ 默认情况下xml中属性的顺序和plist文件中properties的顺序是一致的，所以要想控制属性的设置顺序需要对plist文件中的properties进行排序。但是，对于position、contentSize等属于CCNode的属性，就没办法设置了。
+ 还有下面的几个方案可以调整读取属性的顺序:
 + 在生成xml配置的时候，对属性进行排序。这样在C++中读取xml配置的时候就会按照特定的顺序。
 + 在C++代码中写逻辑保证属性的设置顺序。

*** 在自定义的GTab中添加CCMenuItem以后，其中的CCMenuItem无法移动。
这是因为GTab截取了mouseDown事件。只要在GTab的init中调用［setTouchEnable false］就可以了。

*** 如何添加新的RootNode?
CocosBuilder默认的RootNode类型只有:CCNode CCLayer CCSprite等几种。要想使自定义的节点能作为Root节点，需要在PropertyList中设置canBeRootNode=YES。
需要注意的是，RootNode的canBeFullScreen属性，需要修改CocosBuilder的源代码(NewDocWindowController的canBeFullScreen方法)。

*** CocosBuilder的一些代码逻辑
**** CocosBuilder启动时做的初始化工作
#+BEGIN_EXAMPLE
CocosBuilderAppDelegate.m - (void)applicationDidFinishLaunching:(NSNotification *)aNotification
#+END_EXAMPLE
**** 添加一个节点到场景的代码逻辑
#+BEGIN_EXAMPLE
1、CocosBuilderAppDelegate.m - (void) addPlugInNodeNamed:(NSString*)name asChild:(BOOL) asChild
2、PluginManager.m - (CCNode*) createDefaultNodeOfType:(NSString*)name
(1)创建出来Node，需要注意创建出来的是编辑类型的Node。
(2)为Node设置初始默认属性。
3、
#+END_EXAMPLE
**** 在CocosBuilder中选中一个节点时的代码执行逻辑
#+BEGIN_EXAMPLE

#+END_EXAMPLE
**** 菜单按钮的Disable Enable控制
#+BEGIN_EXAMPLE
CocosBuilderAppDelegate.m - (BOOL) validateMenuItem:(NSMenuItem *)menuItem
#+END_EXAMPLE
**** 放置控件Plugin的Toolbar代码逻辑
#+BEGIN_EXAMPLE
MainToolBarDelegate.m
例如：点击SpritePlugin图标添加Sprite控件时，会调用MainToolBarDelegate.m - (void) selectedItem:(id) sender
#+END_EXAMPLE
**** 菜单Animation-Start BezierPos disable
#+BEGIN_EXAMPLE
说明：自定义的粒子类的plist文件已经填写了animatable=YES，不支持start BezierPos关健帧。
(1)在下面函数中下断点。运行程序，选择Animation-Insert Keyframe时，可以断到这种情况。
SequencerHandler.m - (BOOL) canInsertKeyframeNamed:(NSString*)prop
(2)在下面的函数中返回True或False来决定是否Enable对应的MenuItem。
PluginNode.m - (NSArray*) animatablePropertiesForNode:(CCNode*)node

最后发现是因为MainMenu.xib文件中没有为新添加的MenuItem关联事件处理的代码。
#+END_EXAMPLE
*** CocosBuilder xib的修改
**** xib修改使用的Xcode版本
CocosBuilder_v3.x 中得xib文件使用Xcode 4.6打开。可以在Xcode5中设置xib编辑所使用的xcode版本。
**** InspectorBlock.xib InspectorCodeConnections.xib
#+BEGIN_EXAMPLE
添加Near parent选项。注意这里需要设置tag，不需要为控件关联事件代码。
#+END_EXAMPLE
**** MainMenu.xib
#+BEGIN_EXAMPLE
添加新的关键帧类型，例如 start BezierPos。注意这里需要为控件关联事件代码。
#+END_EXAMPLE
*** 首先需要用C++实现控件，然后为了在CocosBuilder中编辑控件又需要用Objective-C来实现一遍控件，那么是不是需要实现两次控件呢?
#+BEGIN_EXAMPLE
答:首先要搞清楚两次实现控件的目的，C++实现控件是因为游戏内容展示需求所决定的，Objective-C实现控件是为了在CocosBuilder中编辑控件的属性。所以，用Objective-C实现控件的工作应该是很简单的工作，我们不必正真地实现某个控件，只需要模拟出来某个控件，将该控件的一些属性映射到正真的控件属性就可以了。
#+END_EXAMPLE

*** 通过这种方式来使用控件的流程是怎样的呢?
1) 通过CocosBuilder将控件属性导出到xml文件中。
2) 在游戏中，读取xml内容，依据xml内容使用Loader来创建控件对象，设置控件的属性
#+BEGIN_EXAMPLE
需要注意的问题:
1、onResolveCCBCCControlSelector、onResolveCCBCCMenuItemSelector这两个函数的作用是依据Block的Selector内容来获得对应的函数指针。
2、onHandlePropTypeBlock、onHandlePropTypeBlockCCControl这两个函数是设置控件的事件响应函数。
3、onAssignCCBMemberVariable的作用是依据CocosBuilder属性编辑选项CodeConnection中第二项的内容(Target、VariableName)来赋值引用UI元素的变量。注意，变量的绑定和事件响应函数的绑定不同。
#+END_EXAMPLE

*** 属性plist文件的编辑中，需要注意的几个问题:
+ 将属性放置在propertiesOverridden下，可以覆盖父类的属性设置。
+ 将属性设置为readOnly＝Yes时，该属性将不会被写到ccb和ccbi文件中。
+ 当属性值等于defaultSerialization时，CocosBuilder会忽略该属性值，而不将其写入ccb文件。

*** 控件的编辑类中属性编辑函数的实现注意事项
CocosBuilder是通过反射机制来动态设置控件的属性的，即在CocosBuilder底层他通过传递名称来调用函数，所以在属性plist中name字段的值要和编辑类中属性设置函数的名称相匹配。
#+BEGIN_EXAMPLE
例如:
GShadowLabelTTF 中有一下代码:
//.h file
@interface GShadowLabelTTF
{
    GShadowType shadowType;
}
@property (nonatomic,assign,readwrite,setter = setShadowType:)GShadowType shadowType;
//.m file
@synthesize shadowType;
那么在其对应的plist中name所对应的值也需要填写shadowType
#+END_EXAMPLE
